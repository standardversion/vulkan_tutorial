# 🔍 Generating Mipmaps – Texture LOD in Vulkan

> Mipmaps are precomputed, downscaled versions of a texture used for performance and visual quality.

---

## 🧱 What Are Mipmaps?

- A **mipmap chain** is a series of texture images, each half the dimensions of the previous.
- They improve:
  - **Sampling performance** on distant surfaces
  - **Visual quality** by reducing aliasing and shimmering
- Vulkan supports automatic sampling from mipmaps if properly configured.

---

## ⚙️ Vulkan Requirements for Mipmaps

- Image must be created with:
  - `mipLevels > 1`
  - Usage flags: `VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT`
- Format must support **linear filtering** for `vkCmdBlitImage`
  - Checked with `VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT`

---

## 🏗️ Mipmap Generation with `vkCmdBlitImage`

Mipmaps are generated by blitting (`vkCmdBlitImage`) each level from the previous one. Here's a helper function that encapsulates the entire process:

### 🧩 `generateMipmaps` Function Breakdown

```cpp
void generateMipmaps(VkImage image, VkFormat imageFormat, int32_t texWidth, int32_t texHeight, uint32_t mipLevels);
```

✅ What it does:
1. Validates format – Ensures it supports linear filtering blitting.

2. Begins a command buffer – For single-time execution.

3. For each mip level:

    - Transitions current level to TRANSFER_SRC_OPTIMAL

    -  Defines a blit operation to copy and downscale

    - Executes vkCmdBlitImage

4. Transitions the source level to SHADER_READ_ONLY_OPTIMAL

5. Final mip level is also transitioned for shader use.

6. Submits and ends the command buffer.

🔍 Key Vulkan Concepts in the Function
🔹 Checking Format Capabilities
```cpp
vkGetPhysicalDeviceFormatProperties(...);
```

Ensures the image format supports linear filtering for mipmap blitting:


```cpp
if (!(formatProperties.optimalTilingFeatures & VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT)) {
    throw std::runtime_error("texture image format does not support linear blitting!");
}
```

🔹 Image Layout Transitions with Barriers
Before and after blitting, image layouts are transitioned appropriately using VkImageMemoryBarrier.

```cpp
barrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
barrier.newLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
```
🔹 Mip Level Blit
Downscale image from mip level i-1 to i:

```cpp
vkCmdBlitImage(commandBuffer,
    image, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
    image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
    1, &blit,
    VK_FILTER_LINEAR);
```
Each level is half the width/height of the previous:

```cpp
Copy
Edit
blit.dstOffsets[1] = { mipWidth > 1 ? mipWidth / 2 : 1, mipHeight > 1 ? mipHeight / 2 : 1, 1 };
```
🔹 Transition to Shader Layout
Once a mip level has been read from, it's made shader-readable:

```cpp

barrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
barrier.newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;

```
🪄 Sampler Setup for Mipmaps
Enable mipmap filtering in the sampler:

```cpp
VkSamplerCreateInfo samplerInfo{};
samplerInfo.mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR;
samplerInfo.minLod = 0.0f;
samplerInfo.maxLod = static_cast<float>(mipLevels);
samplerInfo.anisotropyEnable = VK_TRUE;
```

# 🧠 Quick Recap: Mipmap Generation in Vulkan

| Step                   | Vulkan Function / Logic                   | Description                                  |
| ---------------------- | ----------------------------------------- | -------------------------------------------- |
| Format Check           | `vkGetPhysicalDeviceFormatProperties`     | Ensure format supports linear blitting       |
| Create image           | `vkCreateImage` with `mipLevels > 1`      | Reserve memory for full mip chain            |
| Copy base level        | `vkCmdCopyBufferToImage`                  | Upload mip 0 (original resolution)           |
| Loop over mip levels   | `vkCmdBlitImage` + layout transitions     | Downscale each level from the previous       |
| Transition final level | `vkCmdPipelineBarrier`                    | Make last level shader-readable              |
| Create sampler         | `vkCreateSampler` with mipmapping options | Enable correct LOD selection during sampling |


# Diagram
[mipmap-generation](diagrams/generating-mipmaps.md)